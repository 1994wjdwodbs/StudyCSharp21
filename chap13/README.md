# C# 추가 학습

microsoft C# 가이드, 닷넷정복(책)을 참고하였습니다.</br>
(https://docs.microsoft.com/ko-kr/dotnet/csharp/ , http://soen.kr/)

## 대리자
대리자(delegate)는 메서드를 가리키는 참조형입니다. 메서드도 메모리에 존재하므로 위치를 가리키거나</br>
다른 메서드의 인수로 전달할 수 있습니다. C++의 함수 포인터에 대응하는 개념이되 타입 체크가 더 엄격하고</br>
클래스 소속의 메서드도 가리킬 수 있어 객체지향적입니다.

```csharp
지정자 delegate 리턴타입 이름(인수목록);
```

액세스 가능한 클래스 또는 대리자 형식과 일치하는 구조의 모든 메서드는 대리자에 할당할 수 있습니다.</br>
메서드는 정적 메서드이거나 인스턴스 메서드일 수 있습니다. 이러한 유연성은 프로그래밍 방식으로</br>
메서드 호출을 변경하거나 기존 클래스에 새 코드를 삽입할 수 있음을 의미합니다.</br>

대리자에서는 이와 같이 메서드를 매개 변수로 취급할 수 있으므로 __대리자는 콜백 메서드 정의에 이상적__ 입니다.</br>

- __대리자 개요__

> 대리자는 C++ 함수 포인터와 유사하지만 C++ 함수 포인터와 달리 멤버 함수에 대해 완전히 개체 지향입니다.</br>
> 대리자는 개체 인스턴스 및 메서드를 모두 캡슐화합니다.
>
> 대리자를 통해 메서드를 매개 변수로 전달할 수 있습니다.</br>
> 
> 대리자를 사용하여 콜백 메서드를 정의할 수 있습니다.</br>
> 
> 여러 대리자를 연결할 수 있습니다. 예를 들어 단일 이벤트에 대해 여러 메서드를 호출할 수 있습니다.</br>
> 
> 메서드는 대리자 형식과 정확히 일치하지 않아도 됩니다. (자세한 내용은 대리자의 가변성 사용을 참조하세요.)</br>
> 
> 람다 식은 인라인 코드 블록을 작성하는 더욱 간단한 방법입니다. 특정 컨텍스트에서는 람다 식이 대리자 형식으로 컴파일됩니다.

- __코드의 의존성 문제__

코드의 의존성이 높아지는 이유는 두 가지가 있다. 하나는 다른 함수를 사용하는데 들어가는 연결이며,<br/>
다른 하나는 자료구조를 직접적으로 다루는데 따른 것이다. <br/>
즉, 둘 다 내부적인 변경에 대해서 사용자 측의 코드 변경을 동반할 가능성이 높다. <br/>
또 다른 한 가지의 이유를 더 추가하자면, 함수나 자료구조에 대한 책임과 역할이 명확하지 않다는 점이다. <br/>
즉, 어떤 모듈이(혹은, 함수가) 어떤 일을 해주어야 하는지 명확하지 않아서, 서로가 서로를 의존하도록 만드는 경우에 해당한다. <br/>
<br/>
순환적인 의존성을 끊는 것은 생각보다 간단하다. 크게 두 가지 방법을 활용할 수 있는데, <br/>
첫 번째는 함수의 위치를 옮기는 것이다. 즉, 순환의 고리상 마지막에 위치하는 함수를 사용되는 위치로 옮겨놓는 것이다. <br/>
물론, 이름도 같이 변경해 주는 것이 좋다. <br/>
예를 들어, 모듈의 이름을 함수의 이름 앞에 사용하는 것은 함수의 위치를 명확히 해 줄 수 있다는 점에서 도움이 된다<br/>
(임베디드 시스템에서 주로 사용). 순환 고리상 자료구조에 의존적인 코드라 그곳에 밖에 위치할 수 없다고 이야기할 경우도 있을 것이다. <br/>
이 때는 사용할 자료구조와 함수를 같이 넘겨서, 콜백(Callback)함수로 만들어 줄 수도 있을 것이다. <br/>
<br/>
의존관계 중에서 자료구조의 의존관계나 사용되는 자료의 의존관계를 정리하기 위해서는 좀 더 주의가 요구된다. <br/>
자료구조에 대한 의존성은 자료구조를 다루는 전담 함수들을 만들어서 처리하면 되지만 <br/>
만약, 긴 함수의 체인(Chain)을 따라 내려가야 하는 파라미터를 이용한다면, 그것이 과연 필요한지도 생각해야 할 것이다. <br/>
예를 들어, IP(Internet Protocol) 패킷과 같은 것을 처리해야하는 경우, 각각의 계층을 거치면서 해주어야 할 일이 다르다. <br/>
그리고, 자주 데이터를 옮기는 것도 메모리 복사를 발생시키기에 처리속도를 늦춘다.<br/>
이런 상황이라면, 패킷을 할당받을 경우 속도 향상을 위해서 CPU 구조에 맞는 바이트(Byte)단위의 정렬(Align)을 만들어야 하고 <br/>
잦은 데이터의 복사를 줄이기 위해서 포인터를 이용해서, 함수의 호출을 하게 될 것이다. <br/>
데이터의 이동대신에 패킷을 나타내는 자료구조를 사용하고 <br/>
그 자료구조에 실제 데이터를 저장하는 공간에 대한 포인터를 유지할 수 있다. <br/>

[이전](https://github.com/1994wjdwodbs/StudyCSharp21)
